// Code generated by gnorm. Source: ../gnorm/templates/table.gotmpl. DO NOT EDIT!

package playerlp

import (
	"context"
	"database/sql"

	"github.com/heedson/riotgear/armoury/armoury"
	"github.com/heedson/riotgear/shield"
)

// Row represents a row from 'player_lp'
type Row struct {
	PlayerID int // player_id (PK)
	MatchID  int // match_id (PK)
	LpGain   int // lp_gain
	TotalLp  int // total_lp
}

var (
	// PlayerIDCol is a field representing the column 'player_id' (PK)
	PlayerIDCol armoury.IntField = "player_id"
	// MatchIDCol is a field representing the column 'match_id' (PK)
	MatchIDCol armoury.IntField = "match_id"
	// LpGainCol is a field representing the column 'lp_gain'
	LpGainCol armoury.IntField = "lp_gain"
	// TotalLpCol is a field representing the column 'total_lp'
	TotalLpCol armoury.IntField = "total_lp"
)

// Insert inserts a row into the 'player_lp' table and returns an error if one occurs.
func Insert(ctx context.Context, tx sql.Tx, r *Row) error {
	const insertStr = `INSERT INTO player_lp (
            player_id, match_id, lp_gain, total_lp
        ) VALUES (
            $1, $2, $3, $4
        )`

	_, err := db.Exec(sqlstr, r.PlayerID, r.MatchID, r.LpGain, r.TotalLp)
	return shield.Wrap(shield.Internal, err, "Insert into 'PlayerLp'")
}

// Query queries the 'player_lp' table with the given where clauses and sorts. It returns them as a slice of Rows.
func Query(ctx context.Context, tx sql.Tx, clause armoury.Clause) ([]*Row, error) {
	const selectStr = "SELECT player_id, match_id, lp_gain, total_lp FROM player_lp"

	idx := 1
	sqlStr := selectStr + clause.String(&idx)

	var resp []*Row
	rows, err := tx.Query(ctx, "", sqlStr, clause.Values()...)
	if err != nil {
		return nil, shield.WithStack(shield.Internal, err)
	}
	defer rows.Close()

	for rows.Next() {
		var r Row
		err = rows.Scan(&r.PlayerID, &r.MatchID, &r.LpGain, &r.TotalLp)
		if err != nil {
			return nil, shield.WithStack(shield.Internal, err)
		}

		resp = append(resp, &r)
	}
	if rows.Err() != nil {
		return nil, shield.WithStack(shield.Internal, err)
	}

	if len(resp) == 0 {
		return nil, shield.Error(shield.NotFound, "Query on 'PlayerLp'. No results found")
	}

	return resp, nil
}

// One queries the 'player_lp' table with the given where clauses. It returns only one Row and will error when more than one would be returned.
func One(ctx context.Context, tx sql.Tx, whereClause armoury.WhereClause) (*Row, error) {
	rows, err := Query(ctx, tx, store.QueryClause(whereClause, store.UnOrdered))
	if err != nil {
		return nil, err
	}

	if len(rows) != 1 {
		return nil, shield.Error(shield.InvalidArgument, "One on 'PlayerLp'. Where clause did not return one row")
	}

	return rows[0], nil
}
