// Code generated by gnorm. Source: ../gnorm/templates/table.gotmpl. DO NOT EDIT!

package {{ toLower .Table.Name }}

import (
    "context"
    "database/sql"

    "github.com/heedson/riotgear/armoury/armoury"
    "github.com/heedson/riotgear/shield"
)

{{ $rootPkg := .Params.RootPkg -}}

// Row represents a row from '{{ .Table.DBName }}'
type Row struct {
{{- range .Table.Columns }}
    {{ .Name }} {{ .Type }} // {{ .DBName }}{{ if .IsPrimaryKey }} (PK) {{- end }}
    {{- if .IsFK }} (FK from '{{ .FKColumn.RefColumn.Table.DBName }}') {{- end }}
{{- end }}
}

var (
{{- range .Table.Columns }}
    // {{ .Name}}Col is a field representing the column '{{ .DBName }}'{{ if .IsPrimaryKey }} (PK) {{- end }}
    {{- if .IsFK }} (FK from '{{ .FKColumn.RefColumn.Table.DBName }}') {{- end }}
    {{ if (hasPrefix .Type (printf "%s." $rootPkg)) -}}
        {{ .Name }}Col {{ .Type }}Field = "{{ .DBName }}"
    {{ else -}}
        {{ .Name }}Col {{ $rootPkg }}.{{ title (replace (replace .Type "*pgtype." "" 1) "." "" 1) }}Field = "{{ .DBName }}" 
    {{- end }}
{{- end }}
)

{{- define "values" -}}
{{ $nums := numbers 1 . -}}
{{ $indices := $nums.Sprintf "$%s" -}}
{{ join $indices ", " -}}
{{ end }}

// Insert inserts a row into the '{{ .Table.DBName }}' table and returns an error if one occurs. 
func Insert(ctx context.Context, tx sql.Tx, r *Row) error {
    const insertStr = `INSERT INTO {{ .Table.DBName }} (
            {{ join .Table.Columns.DBNames ", " }}
        ) VALUES (
            {{template "values" (len .Table.Columns) }}
        )`

    _, err := db.Exec(sqlstr, {{ join (.Table.Columns.Names.Sprintf "r.%s") ", " }})
	return shield.Wrap(shield.Internal, err, "Insert into '{{ .Table.Name }}'")
}

// Query queries the '{{ .Table.DBName }}' table with the given where clauses and sorts. It returns them as a slice of Rows.
func Query(ctx context.Context, tx sql.Tx, clause {{ $rootPkg }}.Clause) ([]*Row, error) {
    const selectStr = "SELECT {{ join .Table.Columns.DBNames ", " }} FROM {{ .Table.DBName }}"

    idx := 1
    sqlStr := selectStr + clause.String(&idx)

    var resp []*Row
    rows, err := tx.Query(ctx, "", sqlStr, clause.Values()...)
    if err != nil {
        return nil, shield.WithStack(shield.Internal, err)
    }
    defer rows.Close()

    for rows.Next() {
        var r Row
        err = rows.Scan({{ join (.Table.Columns.Names.Sprintf "&r.%s") ", " }})
        if err != nil {
            return nil, shield.WithStack(shield.Internal, err)
        }

        resp = append(resp, &r)
    }
    if rows.Err() != nil {
        return nil, shield.WithStack(shield.Internal, err)
    }

    if len(resp) == 0 {
        return nil, shield.Error(shield.NotFound, "Query on '{{ .Table.Name }}'. No results found")
    }

    return resp, nil
}

// One queries the '{{ .Table.DBName }}' table with the given where clauses. It returns only one Row and will error when more than one would be returned.
func One(ctx context.Context, tx sql.Tx, whereClause {{ $rootPkg }}.WhereClause) (*Row, error) {
    rows, err := Query(ctx, tx, store.QueryClause(whereClause, store.UnOrdered))
    if err != nil {
        return nil, err
    }

    if len(rows) != 1 {
        return nil, shield.Error(shield.InvalidArgument, "One on '{{ .Table.Name }}'. Where clause did not return one row")
    }

    return rows[0], nil
}

