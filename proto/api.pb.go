// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		api.proto

	It has these top-level messages:
		PlayerReq
		PlayerID
		PlayerRank
*/
package proto

import proto1 "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/mwitkow/go-proto-validators"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// PlayerReq is a message with a region and player name used to request various resources
// using a player name rather than a harder-to-remember player ID.
type PlayerReq struct {
	// RegionName is the name of the region to make the request to.
	RegionName string `protobuf:"bytes,1,opt,name=region_name,json=regionName,proto3" json:"region_name,omitempty"`
	// PlayerName is the name of the player to retrieve the specific resources for.
	PlayerName string `protobuf:"bytes,2,opt,name=player_name,json=playerName,proto3" json:"player_name,omitempty"`
}

func (m *PlayerReq) Reset()                    { *m = PlayerReq{} }
func (m *PlayerReq) String() string            { return proto1.CompactTextString(m) }
func (*PlayerReq) ProtoMessage()               {}
func (*PlayerReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

func (m *PlayerReq) GetRegionName() string {
	if m != nil {
		return m.RegionName
	}
	return ""
}

func (m *PlayerReq) GetPlayerName() string {
	if m != nil {
		return m.PlayerName
	}
	return ""
}

// PlayerID is a message with a player's ID. This is useful for potential API queries that
// require a player ID instead of a player name.
type PlayerID struct {
	PlayerId int64 `protobuf:"varint,1,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"`
}

func (m *PlayerID) Reset()                    { *m = PlayerID{} }
func (m *PlayerID) String() string            { return proto1.CompactTextString(m) }
func (*PlayerID) ProtoMessage()               {}
func (*PlayerID) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

func (m *PlayerID) GetPlayerId() int64 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

// PlayerRank is a message that contains all of the ranked data of a single player.
type PlayerRank struct {
	// LeaguePositions is a list of league positions for the player.
	LeaguePositions []*PlayerRank_LeaguePosition `protobuf:"bytes,1,rep,name=league_positions,json=leaguePositions" json:"league_positions,omitempty"`
}

func (m *PlayerRank) Reset()                    { *m = PlayerRank{} }
func (m *PlayerRank) String() string            { return proto1.CompactTextString(m) }
func (*PlayerRank) ProtoMessage()               {}
func (*PlayerRank) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

func (m *PlayerRank) GetLeaguePositions() []*PlayerRank_LeaguePosition {
	if m != nil {
		return m.LeaguePositions
	}
	return nil
}

// LeaguePosition is data for an individual ranked queue.
type PlayerRank_LeaguePosition struct {
	// Rank is the rank within a given league. i.e I, II, III, IV, V
	Rank string `protobuf:"bytes,1,opt,name=rank,proto3" json:"rank,omitempty"`
	// QueueType is the name of the queue that these stats are for.
	// i.e. RANKED_SOLO_5x5, RANKED_FLEX_SR.
	QueueType string `protobuf:"bytes,2,opt,name=queue_type,json=queueType,proto3" json:"queue_type,omitempty"`
	// HotStreak is whether the player is currently in a 3 or more game winning streak.
	HotStreak bool `protobuf:"varint,3,opt,name=hot_streak,json=hotStreak,proto3" json:"hot_streak,omitempty"`
	// MiniSeries is the details on an ongoing mini series that the player may be in.
	MiniSeries *PlayerRank_LeaguePosition_MiniSeries `protobuf:"bytes,4,opt,name=mini_series,json=miniSeries" json:"mini_series,omitempty"`
	// Wins is the number of wins the player has in total in this queue type.
	Wins int64 `protobuf:"varint,5,opt,name=wins,proto3" json:"wins,omitempty"`
	// Veteran is true when the player has more than 100 games played in their current league.
	Veteran bool `protobuf:"varint,6,opt,name=veteran,proto3" json:"veteran,omitempty"`
	// Losses is the number of losses the player has in total in this queue type.
	Losses int64 `protobuf:"varint,7,opt,name=losses,proto3" json:"losses,omitempty"`
	// FreshBlood is true when the player has less than 50 (Maybe?) games played in their current league.
	FreshBlood bool `protobuf:"varint,8,opt,name=fresh_blood,json=freshBlood,proto3" json:"fresh_blood,omitempty"`
	// LeagueId is the unique name of the player's current league.
	LeagueId string `protobuf:"bytes,9,opt,name=league_id,json=leagueId,proto3" json:"league_id,omitempty"`
	// PlayerOrTeamName is the name of the individual player or ranked team of players.
	PlayerOrTeamName string `protobuf:"bytes,10,opt,name=player_or_team_name,json=playerOrTeamName,proto3" json:"player_or_team_name,omitempty"`
	// Inactive <Not sure myself...>
	Inactive bool `protobuf:"varint,11,opt,name=inactive,proto3" json:"inactive,omitempty"`
	// PlayerOrTeamId is the ID of the individual player or ranked team of players.
	PlayerOrTeamId string `protobuf:"bytes,12,opt,name=player_or_team_id,json=playerOrTeamId,proto3" json:"player_or_team_id,omitempty"`
	// LeagueName is the human readable, lore-tied name of the player's league. e.g. "Urgot's Maulers".
	LeagueName string `protobuf:"bytes,13,opt,name=league_name,json=leagueName,proto3" json:"league_name,omitempty"`
	// Tier is the tier name of the player's rank. i.e. BRONZE, SILVER, GOLD, PLATINUM, etc.
	Tier string `protobuf:"bytes,14,opt,name=tier,proto3" json:"tier,omitempty"`
	// LeaguePoints is the current number of points the player has in the ranked ladder.
	LeaguePoints int64 `protobuf:"varint,15,opt,name=league_points,json=leaguePoints,proto3" json:"league_points,omitempty"`
}

func (m *PlayerRank_LeaguePosition) Reset()                    { *m = PlayerRank_LeaguePosition{} }
func (m *PlayerRank_LeaguePosition) String() string            { return proto1.CompactTextString(m) }
func (*PlayerRank_LeaguePosition) ProtoMessage()               {}
func (*PlayerRank_LeaguePosition) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2, 0} }

func (m *PlayerRank_LeaguePosition) GetRank() string {
	if m != nil {
		return m.Rank
	}
	return ""
}

func (m *PlayerRank_LeaguePosition) GetQueueType() string {
	if m != nil {
		return m.QueueType
	}
	return ""
}

func (m *PlayerRank_LeaguePosition) GetHotStreak() bool {
	if m != nil {
		return m.HotStreak
	}
	return false
}

func (m *PlayerRank_LeaguePosition) GetMiniSeries() *PlayerRank_LeaguePosition_MiniSeries {
	if m != nil {
		return m.MiniSeries
	}
	return nil
}

func (m *PlayerRank_LeaguePosition) GetWins() int64 {
	if m != nil {
		return m.Wins
	}
	return 0
}

func (m *PlayerRank_LeaguePosition) GetVeteran() bool {
	if m != nil {
		return m.Veteran
	}
	return false
}

func (m *PlayerRank_LeaguePosition) GetLosses() int64 {
	if m != nil {
		return m.Losses
	}
	return 0
}

func (m *PlayerRank_LeaguePosition) GetFreshBlood() bool {
	if m != nil {
		return m.FreshBlood
	}
	return false
}

func (m *PlayerRank_LeaguePosition) GetLeagueId() string {
	if m != nil {
		return m.LeagueId
	}
	return ""
}

func (m *PlayerRank_LeaguePosition) GetPlayerOrTeamName() string {
	if m != nil {
		return m.PlayerOrTeamName
	}
	return ""
}

func (m *PlayerRank_LeaguePosition) GetInactive() bool {
	if m != nil {
		return m.Inactive
	}
	return false
}

func (m *PlayerRank_LeaguePosition) GetPlayerOrTeamId() string {
	if m != nil {
		return m.PlayerOrTeamId
	}
	return ""
}

func (m *PlayerRank_LeaguePosition) GetLeagueName() string {
	if m != nil {
		return m.LeagueName
	}
	return ""
}

func (m *PlayerRank_LeaguePosition) GetTier() string {
	if m != nil {
		return m.Tier
	}
	return ""
}

func (m *PlayerRank_LeaguePosition) GetLeaguePoints() int64 {
	if m != nil {
		return m.LeaguePoints
	}
	return 0
}

// MiniSeries is the data for a potential "promotion series" or any other sort of
// important mini series.
type PlayerRank_LeaguePosition_MiniSeries struct {
	// Wins is the number of wins for the player in an ongoing mini series.
	// If there isn't an ongoing mini series then this is 0.
	Wins int64 `protobuf:"varint,1,opt,name=wins,proto3" json:"wins,omitempty"`
	// Losses is the number of losses for the player in an ongoing mini series.
	// If there isn't an ongoing mini series then this is 0.
	Losses int64 `protobuf:"varint,2,opt,name=losses,proto3" json:"losses,omitempty"`
	// Target is the target number of wins to succeed in the mini series.
	// If there isn't an ongoing mini series then this is 0.
	Target int64 `protobuf:"varint,3,opt,name=target,proto3" json:"target,omitempty"`
	// Progress <Not sure myself...>
	// If there isn't an ongoing mini series then this is an empty string.
	Progress string `protobuf:"bytes,4,opt,name=progress,proto3" json:"progress,omitempty"`
}

func (m *PlayerRank_LeaguePosition_MiniSeries) Reset()         { *m = PlayerRank_LeaguePosition_MiniSeries{} }
func (m *PlayerRank_LeaguePosition_MiniSeries) String() string { return proto1.CompactTextString(m) }
func (*PlayerRank_LeaguePosition_MiniSeries) ProtoMessage()    {}
func (*PlayerRank_LeaguePosition_MiniSeries) Descriptor() ([]byte, []int) {
	return fileDescriptorApi, []int{2, 0, 0}
}

func (m *PlayerRank_LeaguePosition_MiniSeries) GetWins() int64 {
	if m != nil {
		return m.Wins
	}
	return 0
}

func (m *PlayerRank_LeaguePosition_MiniSeries) GetLosses() int64 {
	if m != nil {
		return m.Losses
	}
	return 0
}

func (m *PlayerRank_LeaguePosition_MiniSeries) GetTarget() int64 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *PlayerRank_LeaguePosition_MiniSeries) GetProgress() string {
	if m != nil {
		return m.Progress
	}
	return ""
}

func init() {
	proto1.RegisterType((*PlayerReq)(nil), "PlayerReq")
	golang_proto.RegisterType((*PlayerReq)(nil), "PlayerReq")
	proto1.RegisterType((*PlayerID)(nil), "PlayerID")
	golang_proto.RegisterType((*PlayerID)(nil), "PlayerID")
	proto1.RegisterType((*PlayerRank)(nil), "PlayerRank")
	golang_proto.RegisterType((*PlayerRank)(nil), "PlayerRank")
	proto1.RegisterType((*PlayerRank_LeaguePosition)(nil), "PlayerRank.LeaguePosition")
	golang_proto.RegisterType((*PlayerRank_LeaguePosition)(nil), "PlayerRank.LeaguePosition")
	proto1.RegisterType((*PlayerRank_LeaguePosition_MiniSeries)(nil), "PlayerRank.LeaguePosition.MiniSeries")
	golang_proto.RegisterType((*PlayerRank_LeaguePosition_MiniSeries)(nil), "PlayerRank.LeaguePosition.MiniSeries")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Riotgear service

type RiotgearClient interface {
	// GetPlayerID returns the player ID when given the region and a player name.
	// This is just an example use of Riot's League of Lengend's API.
	GetPlayerID(ctx context.Context, in *PlayerReq, opts ...grpc.CallOption) (*PlayerID, error)
	// GetPlayerRank returns the rank stats for all queue types for a given player name
	// on a given region.
	GetPlayerRank(ctx context.Context, in *PlayerReq, opts ...grpc.CallOption) (*PlayerRank, error)
}

type riotgearClient struct {
	cc *grpc.ClientConn
}

func NewRiotgearClient(cc *grpc.ClientConn) RiotgearClient {
	return &riotgearClient{cc}
}

func (c *riotgearClient) GetPlayerID(ctx context.Context, in *PlayerReq, opts ...grpc.CallOption) (*PlayerID, error) {
	out := new(PlayerID)
	err := grpc.Invoke(ctx, "/Riotgear/GetPlayerID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *riotgearClient) GetPlayerRank(ctx context.Context, in *PlayerReq, opts ...grpc.CallOption) (*PlayerRank, error) {
	out := new(PlayerRank)
	err := grpc.Invoke(ctx, "/Riotgear/GetPlayerRank", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Riotgear service

type RiotgearServer interface {
	// GetPlayerID returns the player ID when given the region and a player name.
	// This is just an example use of Riot's League of Lengend's API.
	GetPlayerID(context.Context, *PlayerReq) (*PlayerID, error)
	// GetPlayerRank returns the rank stats for all queue types for a given player name
	// on a given region.
	GetPlayerRank(context.Context, *PlayerReq) (*PlayerRank, error)
}

func RegisterRiotgearServer(s *grpc.Server, srv RiotgearServer) {
	s.RegisterService(&_Riotgear_serviceDesc, srv)
}

func _Riotgear_GetPlayerID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RiotgearServer).GetPlayerID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Riotgear/GetPlayerID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RiotgearServer).GetPlayerID(ctx, req.(*PlayerReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Riotgear_GetPlayerRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RiotgearServer).GetPlayerRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Riotgear/GetPlayerRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RiotgearServer).GetPlayerRank(ctx, req.(*PlayerReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Riotgear_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Riotgear",
	HandlerType: (*RiotgearServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPlayerID",
			Handler:    _Riotgear_GetPlayerID_Handler,
		},
		{
			MethodName: "GetPlayerRank",
			Handler:    _Riotgear_GetPlayerRank_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *PlayerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RegionName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RegionName)))
		i += copy(dAtA[i:], m.RegionName)
	}
	if len(m.PlayerName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PlayerName)))
		i += copy(dAtA[i:], m.PlayerName)
	}
	return i, nil
}

func (m *PlayerID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	return i, nil
}

func (m *PlayerRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerRank) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LeaguePositions) > 0 {
		for _, msg := range m.LeaguePositions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PlayerRank_LeaguePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerRank_LeaguePosition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rank) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Rank)))
		i += copy(dAtA[i:], m.Rank)
	}
	if len(m.QueueType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.QueueType)))
		i += copy(dAtA[i:], m.QueueType)
	}
	if m.HotStreak {
		dAtA[i] = 0x18
		i++
		if m.HotStreak {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MiniSeries != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MiniSeries.Size()))
		n1, err := m.MiniSeries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Wins != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Wins))
	}
	if m.Veteran {
		dAtA[i] = 0x30
		i++
		if m.Veteran {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Losses != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Losses))
	}
	if m.FreshBlood {
		dAtA[i] = 0x40
		i++
		if m.FreshBlood {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.LeagueId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.LeagueId)))
		i += copy(dAtA[i:], m.LeagueId)
	}
	if len(m.PlayerOrTeamName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PlayerOrTeamName)))
		i += copy(dAtA[i:], m.PlayerOrTeamName)
	}
	if m.Inactive {
		dAtA[i] = 0x58
		i++
		if m.Inactive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PlayerOrTeamId) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PlayerOrTeamId)))
		i += copy(dAtA[i:], m.PlayerOrTeamId)
	}
	if len(m.LeagueName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.LeagueName)))
		i += copy(dAtA[i:], m.LeagueName)
	}
	if len(m.Tier) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tier)))
		i += copy(dAtA[i:], m.Tier)
	}
	if m.LeaguePoints != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LeaguePoints))
	}
	return i, nil
}

func (m *PlayerRank_LeaguePosition_MiniSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerRank_LeaguePosition_MiniSeries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Wins != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Wins))
	}
	if m.Losses != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Losses))
	}
	if m.Target != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Target))
	}
	if len(m.Progress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Progress)))
		i += copy(dAtA[i:], m.Progress)
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PlayerReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.RegionName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.PlayerName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *PlayerID) Size() (n int) {
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	return n
}

func (m *PlayerRank) Size() (n int) {
	var l int
	_ = l
	if len(m.LeaguePositions) > 0 {
		for _, e := range m.LeaguePositions {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *PlayerRank_LeaguePosition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Rank)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.QueueType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.HotStreak {
		n += 2
	}
	if m.MiniSeries != nil {
		l = m.MiniSeries.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Wins != 0 {
		n += 1 + sovApi(uint64(m.Wins))
	}
	if m.Veteran {
		n += 2
	}
	if m.Losses != 0 {
		n += 1 + sovApi(uint64(m.Losses))
	}
	if m.FreshBlood {
		n += 2
	}
	l = len(m.LeagueId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.PlayerOrTeamName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Inactive {
		n += 2
	}
	l = len(m.PlayerOrTeamId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.LeagueName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Tier)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.LeaguePoints != 0 {
		n += 1 + sovApi(uint64(m.LeaguePoints))
	}
	return n
}

func (m *PlayerRank_LeaguePosition_MiniSeries) Size() (n int) {
	var l int
	_ = l
	if m.Wins != 0 {
		n += 1 + sovApi(uint64(m.Wins))
	}
	if m.Losses != 0 {
		n += 1 + sovApi(uint64(m.Losses))
	}
	if m.Target != 0 {
		n += 1 + sovApi(uint64(m.Target))
	}
	l = len(m.Progress)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PlayerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerRank) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerRank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerRank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaguePositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaguePositions = append(m.LeaguePositions, &PlayerRank_LeaguePosition{})
			if err := m.LeaguePositions[len(m.LeaguePositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerRank_LeaguePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaguePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaguePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rank = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotStreak", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HotStreak = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiniSeries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MiniSeries == nil {
				m.MiniSeries = &PlayerRank_LeaguePosition_MiniSeries{}
			}
			if err := m.MiniSeries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wins", wireType)
			}
			m.Wins = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wins |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Veteran", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Veteran = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Losses", wireType)
			}
			m.Losses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Losses |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreshBlood", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FreshBlood = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeagueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeagueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerOrTeamName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerOrTeamName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inactive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inactive = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerOrTeamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerOrTeamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeagueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeagueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaguePoints", wireType)
			}
			m.LeaguePoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaguePoints |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerRank_LeaguePosition_MiniSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiniSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiniSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wins", wireType)
			}
			m.Wins = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wins |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Losses", wireType)
			}
			m.Losses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Losses |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Progress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto1.RegisterFile("api.proto", fileDescriptorApi) }
func init() { golang_proto.RegisterFile("api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 731 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xcd, 0x6e, 0xfb, 0x44,
	0x10, 0x97, 0x9b, 0x34, 0xff, 0x78, 0xd2, 0x2f, 0x16, 0xa9, 0xb2, 0x02, 0x04, 0x93, 0x0a, 0x11,
	0x2a, 0x62, 0x43, 0x10, 0x1c, 0xb8, 0x51, 0x01, 0x55, 0x24, 0x0a, 0x95, 0x5b, 0x09, 0xa9, 0x1c,
	0xa2, 0x6d, 0x3c, 0x75, 0x96, 0xd8, 0x5e, 0x77, 0x77, 0x93, 0xa8, 0xaa, 0x7a, 0xe1, 0xc6, 0x15,
	0x5e, 0x08, 0xc1, 0x85, 0x23, 0x12, 0x2f, 0x80, 0x0a, 0x47, 0x1e, 0x02, 0x79, 0xec, 0xb8, 0x0e,
	0x05, 0x4e, 0x3b, 0xf3, 0xdb, 0xdf, 0xce, 0xf7, 0x2c, 0xd8, 0x3c, 0x13, 0x5e, 0xa6, 0xa4, 0x91,
	0xdd, 0x61, 0x24, 0xcc, 0x6c, 0x71, 0xed, 0x4d, 0x65, 0xe2, 0x47, 0x32, 0x92, 0x3e, 0xc1, 0xd7,
	0x8b, 0x1b, 0xd2, 0x48, 0x21, 0xa9, 0xa4, 0x7f, 0x58, 0xa3, 0x27, 0x2b, 0x61, 0xe6, 0x72, 0xe5,
	0x47, 0x72, 0x48, 0x97, 0xc3, 0x25, 0x8f, 0x45, 0xc8, 0x8d, 0x54, 0xda, 0xaf, 0xc4, 0xf2, 0xdd,
	0xab, 0x91, 0x94, 0x51, 0x8c, 0x3e, 0xcf, 0x84, 0xcf, 0xd3, 0x54, 0x1a, 0x6e, 0x84, 0x4c, 0x75,
	0x79, 0xfb, 0x0e, 0x1d, 0xd3, 0x61, 0x84, 0xe9, 0x50, 0xaf, 0x78, 0x14, 0xa1, 0xf2, 0x65, 0x46,
	0x8c, 0xe7, 0xec, 0xfe, 0x19, 0xd8, 0xe7, 0x31, 0xbf, 0x43, 0x15, 0xe0, 0x2d, 0x7b, 0x1d, 0x3a,
	0x0a, 0x23, 0x21, 0xd3, 0x49, 0xca, 0x13, 0x74, 0x2c, 0xd7, 0x1a, 0xd8, 0x01, 0x14, 0xd0, 0x17,
	0x3c, 0xc1, 0x9c, 0x90, 0x11, 0xbb, 0x20, 0x6c, 0x15, 0x84, 0x02, 0xca, 0x09, 0xfd, 0xb7, 0xa0,
	0x5d, 0x98, 0x1b, 0x7f, 0xc2, 0x5e, 0x01, 0xbb, 0x24, 0x8b, 0x90, 0x6c, 0x35, 0x82, 0x76, 0x01,
	0x8c, 0xc3, 0xfe, 0x4f, 0xdb, 0x00, 0xa5, 0x63, 0x9e, 0xce, 0xd9, 0xa7, 0x70, 0x10, 0x23, 0x8f,
	0x16, 0x38, 0xc9, 0xa4, 0x16, 0x14, 0xa0, 0x63, 0xb9, 0x8d, 0x41, 0x67, 0xd4, 0xf5, 0x9e, 0x68,
	0xde, 0xe7, 0xc4, 0x39, 0x2f, 0x29, 0xc1, 0x7e, 0xbc, 0xa1, 0xeb, 0xee, 0x5f, 0x4d, 0xd8, 0xdb,
	0xe4, 0x30, 0x06, 0x4d, 0xc5, 0xd3, 0x79, 0x99, 0x0c, 0xc9, 0xec, 0x35, 0x80, 0xdb, 0x05, 0x2e,
	0x70, 0x62, 0xee, 0xb2, 0x75, 0x16, 0x36, 0x21, 0x97, 0x77, 0x19, 0xe6, 0xd7, 0x33, 0x69, 0x26,
	0xda, 0x28, 0xe4, 0x73, 0xa7, 0xe1, 0x5a, 0x83, 0x76, 0x60, 0xcf, 0xa4, 0xb9, 0x20, 0x80, 0x7d,
	0x06, 0x9d, 0x44, 0xa4, 0x62, 0xa2, 0x51, 0x09, 0xd4, 0x4e, 0xd3, 0xb5, 0x06, 0x9d, 0xd1, 0x9b,
	0xff, 0x1d, 0xa6, 0x77, 0x26, 0x52, 0x71, 0x41, 0xe4, 0x00, 0x92, 0x4a, 0xce, 0x23, 0x5b, 0x89,
	0x54, 0x3b, 0xdb, 0x54, 0x1a, 0x92, 0x99, 0x03, 0x2f, 0x96, 0x68, 0x50, 0xf1, 0xd4, 0x69, 0x91,
	0xdf, 0xb5, 0xca, 0x0e, 0xa1, 0x15, 0x4b, 0xad, 0x51, 0x3b, 0x2f, 0x88, 0x5f, 0x6a, 0x79, 0x4b,
	0x6e, 0x14, 0xea, 0xd9, 0xe4, 0x3a, 0x96, 0x32, 0x74, 0xda, 0xf4, 0x0a, 0x08, 0x3a, 0xc9, 0x91,
	0xbc, 0x0d, 0x65, 0x69, 0x45, 0xe8, 0xd8, 0x94, 0x6b, 0xbb, 0x00, 0xc6, 0x21, 0x1b, 0xc2, 0xcb,
	0x65, 0x8f, 0xa4, 0x9a, 0x18, 0xe4, 0x49, 0xd1, 0x58, 0x20, 0xda, 0x41, 0x71, 0xf5, 0xa5, 0xba,
	0x44, 0x9e, 0x50, 0xff, 0xbb, 0xd0, 0x16, 0x29, 0x9f, 0x1a, 0xb1, 0x44, 0xa7, 0x43, 0x9e, 0x2a,
	0x9d, 0xbd, 0x0d, 0x2f, 0xfd, 0xc3, 0x94, 0x08, 0x9d, 0x1d, 0x32, 0xb4, 0x57, 0x37, 0x34, 0x0e,
	0xf3, 0x98, 0xcb, 0x90, 0xc8, 0xdb, 0x6e, 0x31, 0x46, 0x05, 0x44, 0x7e, 0x18, 0x34, 0x8d, 0x40,
	0xe5, 0xec, 0x15, 0x4d, 0xcb, 0x65, 0x76, 0x04, 0xbb, 0xd5, 0x88, 0x88, 0xd4, 0x68, 0x67, 0x9f,
	0xea, 0xb0, 0xb3, 0x9e, 0x81, 0x1c, 0xeb, 0xc6, 0x00, 0x67, 0xcf, 0x2b, 0x6c, 0xd5, 0x2a, 0xfc,
	0x54, 0xc7, 0xad, 0x8d, 0x3a, 0x1e, 0x42, 0xcb, 0x70, 0x15, 0xa1, 0xa1, 0x86, 0x37, 0x82, 0x52,
	0xcb, 0x53, 0xce, 0x94, 0x8c, 0x14, 0xea, 0xa2, 0xd5, 0x76, 0x50, 0xe9, 0xa3, 0x9f, 0x2d, 0x68,
	0x07, 0x42, 0x9a, 0x08, 0xb9, 0x62, 0x5f, 0x43, 0xe7, 0x14, 0x4d, 0x35, 0xfd, 0xe0, 0x55, 0x7b,
	0xd5, 0xb5, 0xbd, 0x35, 0xdc, 0xff, 0xe0, 0xdb, 0xdf, 0xfe, 0xfc, 0x61, 0xcb, 0x67, 0x43, 0xda,
	0xde, 0xe5, 0x7b, 0xfe, 0x7d, 0x6d, 0xe3, 0x1e, 0xfc, 0xa2, 0x50, 0xfe, 0x7d, 0x6d, 0xcb, 0x1e,
	0x7c, 0x11, 0xb2, 0x2b, 0xd8, 0xad, 0x8c, 0xd3, 0xc2, 0xd4, 0xcd, 0x77, 0x6a, 0xb3, 0xd7, 0x7f,
	0x97, 0x1c, 0x1c, 0xb3, 0xc1, 0xbf, 0x3b, 0xc8, 0xe7, 0x7f, 0xd3, 0xfc, 0xc9, 0x77, 0xd6, 0xf7,
	0x1f, 0x5f, 0xb0, 0xed, 0x51, 0xe3, 0x2b, 0x71, 0x7e, 0x6c, 0x59, 0xea, 0x14, 0xdc, 0x75, 0x52,
	0xae, 0x46, 0xb5, 0x14, 0x53, 0x74, 0x4f, 0xe9, 0xa7, 0x72, 0x33, 0x25, 0xbf, 0xc1, 0xa9, 0xf1,
	0xd8, 0xd1, 0xcc, 0x98, 0x4c, 0x7f, 0xe4, 0xfb, 0xb5, 0x2f, 0x6c, 0x86, 0x18, 0x6a, 0x99, 0xfa,
	0xaa, 0x7c, 0xfc, 0xcb, 0x63, 0xcf, 0xfa, 0xf5, 0xb1, 0x67, 0xfd, 0xfe, 0xd8, 0xb3, 0x7e, 0xfc,
	0xa3, 0x67, 0x5d, 0xbd, 0xf1, 0x3f, 0xe4, 0xf2, 0xab, 0x6c, 0xd1, 0xf1, 0xfe, 0xdf, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x2c, 0x91, 0x52, 0x17, 0x55, 0x05, 0x00, 0x00,
}
